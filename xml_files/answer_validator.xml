<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:html="http://www.w3.org/1999/xhtml"
	xmlns:alef="http://fiit.stuba.sk/ns/alef"
		version="5.0"
		role="question" 
		xml:id="psi-sg-q-162"
		difficulty="0.9">
	<title>Answer validator 1</title>
	<simplesect role="definition">
		<alef:question type="answer-validator">
			<alef:description>Vysvetlite princíp vodopádového modelu životného cyklu softvéru.</alef:description>
			<alef:answers>
				<alef:answer score="1" group="St 17.00-18.50 T-PC A" week="3">Vodopadovy model je charakterizovany tym, ze az po ukonceni jednej fazy cyklu mozeme zacat s dalsou fazou (napr pri vyvoji), z coho vyplyva velka nevyhoda, pretoze v dalsej faze mozeme zistit, ze by bolo vhodne vratit sa do predoslej a nieco zmenit/zlepsim ale v tomto modely to mozne nie je</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC A" week="3">Vodopádový model funguje tak, ze jednotlive fazy (analyza poziadavie, arch. navrh, specif. navrh, implement. testovanie...) sa vytvaraju separatne. najprv jedna a az po dokonceni sa prechadza nadalsiu. najprv sa spavi analyza poziadaviek, az po jej dokonceni nasleduje archit. narvh atd...</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC A" week="3">Funguje sposobom, ze sa najskor vykona cely proces Analyzy a specifikacie, nasledne Navrhu, Implementacie a Testovania systemu. Vodopadovy model je mozne pouzit vtedy, ak mame vopred kompletne specifikovane poziadavky.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC A" week="3">vodopadovy model - vsetky casti idu po sebe (t.j. najprv analyza a navrh, az potom implementacia), na rozdiel teda od iterativneho modelu neodovzdavame pouzivatelovi softver po ciastkach.  nie prilis popularny model, velka nevyhoda je, ze mnohe problemy spozname az v konecnych fazach vyvoja softveru. chyby potom hladat je casovo aj financne narocne. neda sa dokumentacia (a vyvoj) postupne modifikovat, ako v inych modeloch.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC A" week="3">zaciatok vyvoja urcitej etapy sa zacne az po ukonceni predchadzajucej etapy. na zaciatku musia byt dane vsetky poziadavky na softver, neskore ohhalenie chyby ma za nasledok prerobenie dovtedy hotovych casti.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC A" week="3">Kazda etapa prebieha prave raz. Po dokonceni jendej etapy vyvoja zacina druha. Zacina sa s analyzou potom sa prechadza na navrh atd.</alef:answer>
				<alef:answer score="0" group="St 17.00-18.50 T-PC A" week="3">Na zaciatku sa urcia vsetky fazy vyvoja softveru a za radom sa implementuju. Tu je nevzhoda, ze na zaciatku nevieme vsetky fazy vyvoja presne urcit.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC A" week="3">System sa vytvara po castiach, dalsia cast sa zacne vytvarat az ked je predchadzajuca kompletna.  Toto je vyhodne ak su dobre specifikovane poziadavky a nebudu sa menit (co ale vo vacsine pripadov neplati) alebo sa softver tvori nejakym standardnym, znamym postupom.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">vodopadovy vyvoj softveru je zalozeny na postupoch urcitych casti vyvoja softveru. nikdy nezacne dalsia cast pokym sa neukonci predchadzajuca. vyhodou je ze vidime ako sa postupne softver vyvyja. a ze vieme zdokumentovat co sme v ktorej casti robili, nevyhodu toho je ze na zaciatku nevieme povedat co sa nam moze vyskytnut za problem pri vyvoji a castokrat sa necaka na dokoncenie urcitej casti vyvoja softvaru.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">Jedna etapa vyvoja nasleduje za druhou, az kym sa nedostaneme do poslednej. Vodopadovo sa prelievame z jednej do dalsej. Analyza -&gt; Navrh -&gt; Implementacia -&gt; Testovanie</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">nasledujuca etapa sa zacne vykonavat az po dokonceni predchadzajucej (podobne ako pri V-modeli)</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">kazda etapa zacina po skonceni predoslej etapy(teda postupuju ako vodopad). Nerealne v praxi lebo casto je potrebny navrat k predoslim etapam napr. kvoli uprave chyb alebo zmene specifikacie ci navrhu softveru a nikdy nevieme uy na zaciatku presne specifikovat to co chceme a odhalit vsetky chyby.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">Dalsia cast vyvoja sa vykona az po dokonceni predchadzajucej, ktorej vysledok je vystup. Nevyhodou tohto modelu je ze na zaciatku pouzivatel nevie podat vsetky poziadavky na dany softver a pouzivatel bude moct nazriet na system az v poslednej fazy kde sa moze zistit ze povodne poziadavky neboli splnene a tym sa zvysi cena opravy tohto nedostatku. Vyhodou je viditelnost ukoncenia jednotlivych faz.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">softvare sa vyvyja postupne po castiach po ukonceni jednej casti sa zacne vyvijat az druha tazko sa odhaluju chyby ak sa chyba odhali az ku koncu je velmi problematicke ju odstranit.</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">Jednotlive fazy zivotneho cyklu sa zacnu az po ukonceni predchadzajucej pre  kazdy podproblem.  analyza    -&gt;navrh       -&gt;implementacia          -&gt;testovanie</alef:answer>
				<alef:answer score="0" group="St 17.00-18.50 T-PC B" week="3">Podla mna najhorsi, je dobry iba ked robime nieco co pozname a vieme ako sa to bude &quot;spravat&quot; (vieme ake chyby mozeme ocakavat a vyvarujeme sa im). Ak nam tieto chyby oznami zakaznik po odovzdani dotovej prace, je castokrat problem zmenit alebo vytvorit novy system. Vsetky poziadavky zistime od zakaznika na zaciatku - castokrat je to nemozne, nakolko zakaznik sam nevie co chce..  pri ostatnych modeloch odovzdavame system po castiach a zistujeme dalsie chyby/poziadavky od klienta</alef:answer>
				<alef:answer score="1" group="St 17.00-18.50 T-PC B" week="3">Vodopádový model je prístup k vývoju systému, kde po sebe jednotlivé etapy (špecifikácia poziadaviek, návrh, implementácia...)nasledujú systémom že jedna skončí až potom zacne druhá. Tento prístup má nevýhody v tom že poradie sa často nedodržuje a prípadné chyby v systéme alebo nedokonalé pochopenie požiadaviek klienta sú odhalene az po dokoncení softvéru, príliš neskoro.</alef:answer>
			</alef:answers>
		</alef:question>
	</simplesect>
</article>